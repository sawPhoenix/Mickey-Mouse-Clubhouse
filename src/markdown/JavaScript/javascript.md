




# 作用域
  用来存储变量的规则

## 编译原理
  JavaScript是一门编译语言，与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中移植。
 
 传统编译语言流程：
  1. 分词/词法分析： 
  
  这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。
  
  例如，考虑程序 var a = 2;。这段程序通常会被分解成 为下面这些词法单元：var、a、=、2 、;空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。

  >分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的， 主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简 单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法 单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法 分析。

  2. 解析/语法分析：

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个被称为"抽象语法树"（Abstract Syntax Tree，AST）

    var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下 来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression 的子节。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子 节点。
  
  3. 代码生成：
   
  将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。

    抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指 令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。

  关于引擎如何管理系统资源超出了我们的讨论范围，因此只需要简单地了解 引擎可以根据需要创建并储存变量即可。

  ### Javascript引擎不同之处
  js引擎不会有大量（像其他语言编译器那么多的）的时间用来进行优化，js编译过程大部分情况下发生在执行前的几微秒（甚至更短）内。在作用域背后，js引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。
  
  简单来说，任何js代码片段在执行前都要进行编译（通常）。然后做好执行它的准备，且通常会马上执行。

## 理解作用域

  引擎：从头到尾负责整个JavaScript程序的编译及执行过程；

  编译器：负责语法分析及代码生成等；

  作用域：负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这额标识符的访问权限。

  当执行var a = 2 ；这段代码时。会有两个声明。一个在编译时处理，一个是有引擎在运行时处理
  
  编译器会将其解析成词法单元，然后将词法单元解析成一个树结构。
  处理过程： 
    
    1. 遇到var a，编译器会询问作用域是否已经有一个该名称变量存在于同一个作用域的集合中。是，编译器则忽略该声明，继续编译，否则会在作用域的集合中声明一个新的变量，命名为a。
    2. 便意思为引擎生成运行时所需的代码，这个代码被用来处理a = 2这个操作。引擎运行时会先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量

  如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！

  变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

  编译器如何查询：

  引擎会为变量a进行LHS查询。另外一个查找类型叫RHS查询。
  
  >LHS和RHS的含义：在概念上LHS是赋值操作的目标是谁, RHS赋值操作的源头是谁

  函数调用的时候会用到RHS查询，在向函数内部传参时，会有一个LHS查询(这里的a=2)。
  ```
  function foo(a) { 
    console.log( a ); // 2 
  }
  foo( 2 );
  ```
  如果时声明式函数 var = a function(a) {}，这个函数声明将需要进行LHS查询，然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo，将函数声明理解成前面的LHS和赋值的形式并不合适。
  
  ## 作用域嵌套
  即作用域里面可以创建作用域

  >规则：引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。

  ## 异常
  ```
  function foo(a) { 
    console.log( a + b ); 
    b = a; 
  }
  foo( 2 );
  ```
  第一次对b进行RHS查询时无法找到改变量，会报出ReferenceError异常。
  相较之下，当LHS没有相应的变量，则会创建一个，不过在严格模式下则会报错（ReferenceError和TypeError）。ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法的或不合理的。

  > 全局模式禁止自动或隐式地创建全局变量。


## 词法作用域
作用域主要用两种工作模型，第一种是词法作用域，较为普遍.另一种叫动态作用域,用的不多（Bash脚本，Perl中的一些模式等）

### 词法阶段
词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋 予单词语义。

简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变（大部分情况下是这样的）。

>有一些欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域，但是这种机制可能有点难以理解。事实上，让词法作用域根据自发关系保持书写时的自然关系不变，是一个非常好的最佳实践。

没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡 中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样

**查找:**
作用域查找会在找到第一个匹配的标识符时停止。

### 欺骗词法
  1. eval
    eval会动态执行JavaScript代码，将字符串改成相应的代码，使代码在相应的地方执行。
    在严格模式中eval()有自己的词法作用域，意味着其中的声明无法修改所在的作用域。

  2. with
  关键字，with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。
    
  >尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作 用域中。

  **在严格模式中with和eval()的间接使用以及非安全的使用都被被禁止，而且由于不可知性，优化代码也会变的毫无意义，代码运行起来会特别的慢。**

  ## 函数作用域和块作用域

  ### 函数作用域
  函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。

  隐藏内部实现：

  即用作用域隐藏函数内部的实现，实现低耦合，以免函数内部的变量和函数影响外部代码。

  由于函数内部会被外部或全局变量影响，所以会出现匿名函数

  **匿名函数**：
  function().. 没有名称标识符。函数表达式可以是匿名的， 而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

  缺点： 
  1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
  2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身
  3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

  所以，出现了函数表达式，函数会被包含在函数表达式内部，即:(function foo(){})();
  第一个()即将函数作为一个表达式，第二个()执行了这个函数。
  这一块的术语：IIFE，代表立即执行函数表达式 （Immediately Invoked Function Expression），这里函数名不是必须的。

  >改进式：(function(){ .. }())

  进阶用法(function(global){ .. }(window)) 将参数传进去，参数可以是函数
  ```
   (function IIFE(def) {
    def(window);
  })(function def(global) {
    var a = 3;
    console.log(a); // 3 
    console.log(global.a); // 2 
  });
  ```
 ### 块作用域
  表面上，在ES6之前，js并没有块级作用域的功能。
  不过，还是有几个关键字会触发块作用域
  1. with
  2. try/catch 

  ES6：用花括号{}来作为作用域
  >let:将变量隐式的附加在所在的作用域中

  >const：和let一样，不过是常量

  ## 提升
  变量提升的原因
  引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来。这个机制就是词法作用域的核心内容。

  >只有声明本身会被提升，赋值或其他运行逻辑会被留在原地。

  **每个作用域都会有提升操作,在提升中，函数声明会首先被提升，然后才是变量**


  ## 作用域闭包
  闭包的定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
  ```
  function foo() {
    var a = 2;
    function bar() { 
      console.log(a); 
    }
    return bar;
  }
  var baz = foo(); 
  baz(); // 2 —— 朋友，这就是闭包的效果。
  
  //以下for循环就是一个闭包，利用作用域来实现每秒依次打印1-5
  for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  }

  //思路1：隐式函数
  for (var i=1; i<=5; i++) { 
    (function(j) { 
      setTimeout( function timer() { 
        console.log( j ); 
        }, j*1000 ); })( i );
     }

  //思路2：块作用域
  for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  }
  ```
 ## 模块
  模块就是封装在函数内部的函数，调用内部的函数 

  ### ES5模块机制：
  ```
    var MyModules = (function Manager() {
    var modules = {};
    function define(name, deps, impl) {
      for (var i = 0; i < deps.length; i++) {
        deps[i] = modules[deps[i]];
      }
      modules[name] = impl.apply(impl, deps);
    }
    function get(name) {
      return modules[name];
    }
    return {
      define: define,
      get: get
    };
  })();
  ```
  这段代码的核心是 modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的api，存储在一个根据名字来管理的模块列表中。


  ### ES6模块机制
  ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立 的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。

  import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上（在我们的例子里是 hello）。module 会将整个模块的 API 导入并绑定到一个变量上（在 我们的例子里是 foo 和 bar）。export 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。


# this 

  >thi指向会根据环境变量来改变，如果是在一个对象里面调取函数的this，这里的this指向该对象，如果是声明变量调用函数，则this指向声明变量所在的作用域。
  其原理是在内存中的位置不一样，对象和函数在内存中保存的位置不一样，浏览器引擎会将函数单独保存在内存中，然后再将函数的地址赋值给对象或者声明变量。由于函数是一个单独的值，所以它可以在不同的环境中执行。

首先，我们需要函数的理解调用的位置，在调用时this才会出现，

## 绑定规则
 1. 默认绑定，其他规则无法作用时的默认规则。即函数被调用的作用域。
    全局对象在严格模式下不能被默认绑定。

 2. 隐式绑定：当函数在obj中被调用，this则会隐式绑定到该obj的上下文对象中。

 3. 显式绑定：即bind(),call(), apply()，其变种有：硬绑定，  在调用的函数内部显式绑定，所以无论如何调用，this指向一定会发生改变。
 
 
 4. new绑定
   
    使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 
     1. 创建（或者说构造）一个全新的对象。 
     2. 这个新对象会被执行 [[ 原型 ]] 连接。
     3. 这个新对象会绑定到函数调用的 this。
     4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。
    使用
  ## 优先级
  new是创建一个新的对象，优先级最高，显式绑定是强制改变this指向，优先级次之，隐式转换优先级较低。
  ### 优先级例外
  1. 把null和undefined作为this绑定的对象传入call，apply或bind，这些值在调用时会被忽略。（常见用法：用apply来“展开”一个数组，进行柯里化）这种情况一般不用，因为会导致function里面的this指向全局对象。解决方法是创造一个DMZ空对象，将值带入进去var ø = Object.create( null );
  2. 
    ```
    function foo() { console.log( this.a ); }
    var a = 2;
    var o = { a: 3, foo: foo };
    var p = { a: 4 };
    o.foo(); // 3 
    (p.foo = o.foo)(); // 2
    ```
    赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。
  3. 软绑定
    用软绑定来加大绑定的灵活性，使得绑定函数视情况而选择硬绑定还是显示绑定，又或是隐性绑定

  ```
  if (!Function.prototype.softBind) {
    Function.prototype.softBind = function (obj) {
      var fn = this; // 捕获所有 curried 参数
      var curried = [].slice.call(arguments, 1);
      var bound = function () {
        return fn.apply((!this || this === (window || global)) 
        ? obj 
        : this.curried.concat.apply(curried, arguments));
      }; bound.prototype = Object.create(fn.prototype);
      return bound;
    };
  }
  ```

  使用方法：
  ```
  function foo() { console.log("name: " + this.name); }
  var obj = { name: "obj" }, obj2 = { name: "obj2" }, obj3 = { name: "obj3" };
  var fooOBJ = foo.softBind(obj); fooOBJ(); // name: obj 
  obj2.foo = foo.softBind(obj); obj2.foo(); // name: obj2 <---- 看！！！ 
  fooOBJ.call(obj3); // name: obj3 <---- 看！ 
  setTimeout(obj2.foo, 10); // name: obj <---- 应用了软绑定
  ```

  ## 箭头函数
  箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。
  箭头函数的绑定调用过一次后，会自动绑定到被调用的作用域中，且无法变更，如果第二次绑定到其他作用域上，this也会指向第一次绑定的函数上。



  # 类型
  
  ## 对象

  ### 访问类型
  1. obj.xxx ：属性访问
  2. obj['xxx']：键访问
    
  两者区别： 键访问可以接受任意 UTF-8/Unicode 字符串作为属性名。而且由于键访问使用字符串来访问属性，所以可以在程序中构造这个字符串
  
  例：
  ```
  var myObject = { a:2 };
  var idx;
  if (wantA) { idx = "a"; }
  // 之后 
  console.log( myObject[idx] ); // 2
  ```
这种方式可以用来做可计算属性名，classnames插件用的就是这种方式
  